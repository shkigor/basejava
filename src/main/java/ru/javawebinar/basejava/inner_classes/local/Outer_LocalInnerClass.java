package ru.javawebinar.basejava.inner_classes.local;

/**
 *  *** Method Local Inner classes (внутренние классы в локальном методе) ***
 *
 * Внутренний класс может быть объявлен внутри метода или блока инициализации внешнего класса.
 *
 * Внутренний класс в локальном методе не может использовать локальные переменные внешнего метода до тех пор,
 * пока локальная переменная не будет объявлена как финальная (final) или effectively final/ т.е. не изменятся в методе.
 * Основная причина, по которой необходимо объявлять локальную переменную как финальную заключается в том,
 * что локальная переменная живёт в стеке до тех пор, пока метод находится в стеке.
 * А в случае использования внутреннего класса возможна ситуация, когда экземпляр внутреннего класса живёт в куче и после выхода из метода,
 * но ему может быть необходим доступ к переменной, объявленной в методе.
 * Для этого, компилятор может сохранить копию локальной переменной, которая объявлена как финальная, в поле внутреннего класса для дальнейшего использования.
 *
 * Внутренний класс в локальном методе не может быть помечен как private, protected, static и transient,
 * но может быть помечен как abstract и final, но не оба одновременно.
 */
public class Outer_LocalInnerClass {
    private int a = 11;

    void outerMethod() {
        int x = 98;
        final int y = 981;
//        x++; //ERROR COMPILATION. Need final x variable.
        System.out.println("Метод внешнего класса x = " + x);
        // Внутренний класс является локальным для метода outerMethod()
        class Inner {
            public void innerMethod() {
                System.out.println("Метод внутреннего класса x = " + x);
                a = 1;
                System.out.println("Метод внутреннего класса a = " + a);
            }
        }
        Inner inner = new Inner();
        inner.innerMethod();
    }

    public static void main(String[] args) {
        Outer_LocalInnerClass outer = new Outer_LocalInnerClass();
        outer.outerMethod();
    }
}
